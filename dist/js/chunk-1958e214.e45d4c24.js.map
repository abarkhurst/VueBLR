{"version":3,"sources":["webpack:///./node_modules/@deck.gl/layers/dist/esm/path-layer/path-tesselator.js","webpack:///./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-vertex.glsl.js","webpack:///./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer-fragment.glsl.js","webpack:///./node_modules/@deck.gl/layers/dist/esm/path-layer/path-layer.js","webpack:///./node_modules/@deck.gl/core/dist/esm/utils/tesselator.js","webpack:///./node_modules/@deck.gl/core/dist/esm/index.js"],"names":["Tesselator","START_CAP","END_CAP","INVALID","_Tesselator","PathTesselator","_ref","data","getGeometry","positionFormat","fp64","this","call","attributes","startPositions","size","padding","type","Float64Array","Float32Array","endPositions","segmentTypes","Uint8ClampedArray","startPositions64XyLow","fp64Only","endPositions64XyLow","key","value","attributeName","path","numPoints","getPathLength","isClosed","context","_this$attributes","geometrySize","startPoint","endPoint","isPathClosed","i","vertexStart","ptIndex","getPointOnPath","Number","isFinite","length","positionSize","index","firstPoint","lastPoint","DEFAULT_COLOR","defaultProps","widthUnits","widthScale","min","widthMinPixels","widthMaxPixels","MAX_SAFE_INTEGER","rounded","miterLimit","dashJustified","billboard","getPath","object","getColor","getWidth","getDashArray","ATTRIBUTE_TRANSITION","enter","chunk","subarray","_Layer","PathLayer","apply","arguments","prototype","vs","fs","modules","_this","noAlloc","attributeManager","getAttributeManager","addInstanced","offset","use64bitPositions","transition","accessor","update","calculateStartPositions","shaderAttributes","instanceLeftPositions","instanceStartPositions","calculateEndPositions","instanceEndPositions","instanceRightPositions","instanceTypes","calculateSegmentTypes","instanceStrokeWidths","defaultValue","instanceDashArrays","instanceColors","props","colorFormat","normalized","instancePickingColors","target","encodePickingColor","setState","pathTesselator","_ref2","oldProps","changeFlags","geometryChanged","dataChanged","updateTriggersChanged","all","state","updateGeometry","numInstances","instanceCount","bufferLayout","invalidateAll","extensionsChanged","gl","model","_getModel","_ref3","uniforms","viewport","_this$props","widthMultiplier","distanceScales","metersPerPixel","setUniforms","Object","assign","jointType","alignMode","draw","SEGMENT_INDICES","SEGMENT_POSITIONS","getShaders","id","geometry","drawMode","indices","Uint16Array","positions","isInstanced","attribute","get","layerName","opts","undefined","_opts$attributes","typedArrayManager","indexLayout","vertexCount","_attributeDefs","seal","Array","isArray","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","Symbol","iterator","next","done","dataRange","_rebuildGeometry","err","startRow","endRow","startIndex","Error","visitor","_createIterable","iterable","objectInfo","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","_ref3$startRow","_ref3$endRow","Infinity","_forEachGeometry","dataIndex","getGeometrySize","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","count","name","def","copy","Boolean","allocate","indexStart","geometryIndex","updateGeometryAttributes","_i","experimental","flattenVertices","flatten","fillArray","memoize"],"mappings":"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","file":"js/chunk-1958e214.e45d4c24.js","sourcesContent":["import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { experimental } from '@deck.gl/core';\nvar Tesselator = experimental.Tesselator;\nvar START_CAP = 1;\nvar END_CAP = 2;\nvar INVALID = 4;\n\nvar PathTesselator = function (_Tesselator) {\n  _inherits(PathTesselator, _Tesselator);\n\n  function PathTesselator(_ref) {\n    var data = _ref.data,\n        getGeometry = _ref.getGeometry,\n        positionFormat = _ref.positionFormat,\n        fp64 = _ref.fp64;\n\n    _classCallCheck(this, PathTesselator);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PathTesselator).call(this, {\n      data: data,\n      getGeometry: getGeometry,\n      positionFormat: positionFormat,\n      attributes: {\n        startPositions: {\n          size: 3,\n          padding: 3,\n          type: fp64 ? Float64Array : Float32Array\n        },\n        endPositions: {\n          size: 3,\n          padding: 3,\n          type: fp64 ? Float64Array : Float32Array\n        },\n        segmentTypes: {\n          size: 1,\n          type: Uint8ClampedArray\n        },\n        startPositions64XyLow: {\n          size: 2,\n          padding: 2,\n          fp64Only: true\n        },\n        endPositions64XyLow: {\n          size: 2,\n          padding: 2,\n          fp64Only: true\n        }\n      }\n    }));\n  }\n\n  _createClass(PathTesselator, [{\n    key: \"get\",\n    value: function get(attributeName) {\n      return this.attributes[attributeName];\n    }\n  }, {\n    key: \"getGeometrySize\",\n    value: function getGeometrySize(path) {\n      var numPoints = this.getPathLength(path);\n\n      if (numPoints < 2) {\n        return 0;\n      }\n\n      if (this.isClosed(path)) {\n        return numPoints < 3 ? 0 : numPoints + 1;\n      }\n\n      return numPoints - 1;\n    }\n  }, {\n    key: \"updateGeometryAttributes\",\n    value: function updateGeometryAttributes(path, context) {\n      var _this$attributes = this.attributes,\n          startPositions = _this$attributes.startPositions,\n          endPositions = _this$attributes.endPositions,\n          segmentTypes = _this$attributes.segmentTypes;\n      var geometrySize = context.geometrySize;\n\n      if (geometrySize === 0) {\n        return;\n      }\n\n      var isPathClosed = this.isClosed(path);\n      var startPoint;\n      var endPoint;\n\n      for (var i = context.vertexStart, ptIndex = 0; ptIndex < geometrySize; i++, ptIndex++) {\n        startPoint = endPoint || this.getPointOnPath(path, 0);\n        endPoint = this.getPointOnPath(path, ptIndex + 1);\n        segmentTypes[i] = 0;\n\n        if (ptIndex === 0) {\n          if (isPathClosed) {\n            segmentTypes[i] += INVALID;\n          } else {\n            segmentTypes[i] += START_CAP;\n          }\n        }\n\n        if (ptIndex === geometrySize - 1) {\n          if (isPathClosed) {\n            segmentTypes[i] += INVALID;\n          } else {\n            segmentTypes[i] += END_CAP;\n          }\n        }\n\n        startPositions[i * 3 + 3] = startPoint[0];\n        startPositions[i * 3 + 4] = startPoint[1];\n        startPositions[i * 3 + 5] = startPoint[2] || 0;\n        endPositions[i * 3] = endPoint[0];\n        endPositions[i * 3 + 1] = endPoint[1];\n        endPositions[i * 3 + 2] = endPoint[2] || 0;\n      }\n    }\n  }, {\n    key: \"getPathLength\",\n    value: function getPathLength(path) {\n      if (Number.isFinite(path[0])) {\n        return path.length / this.positionSize;\n      }\n\n      return path.length;\n    }\n  }, {\n    key: \"getPointOnPath\",\n    value: function getPointOnPath(path, index) {\n      if (Number.isFinite(path[0])) {\n        var positionSize = this.positionSize;\n\n        if (index * positionSize >= path.length) {\n          index += 1 - path.length / positionSize;\n        }\n\n        return [path[index * positionSize], path[index * positionSize + 1], positionSize === 3 ? path[index * positionSize + 2] : 0];\n      }\n\n      if (index >= path.length) {\n        index += 1 - path.length;\n      }\n\n      return path[index];\n    }\n  }, {\n    key: \"isClosed\",\n    value: function isClosed(path) {\n      var numPoints = this.getPathLength(path);\n      var firstPoint = this.getPointOnPath(path, 0);\n      var lastPoint = this.getPointOnPath(path, numPoints - 1);\n      return firstPoint[0] === lastPoint[0] && firstPoint[1] === lastPoint[1] && firstPoint[2] === lastPoint[2];\n    }\n  }]);\n\n  return PathTesselator;\n}(Tesselator);\n\nexport { PathTesselator as default };\n//# sourceMappingURL=path-tesselator.js.map","export default \"#define SHADER_NAME path-layer-vertex-shader\\n\\nattribute vec3 positions;\\n\\nattribute float instanceTypes;\\nattribute vec3 instanceStartPositions;\\nattribute vec3 instanceEndPositions;\\nattribute vec3 instanceLeftPositions;\\nattribute vec3 instanceRightPositions;\\nattribute vec2 instanceLeftPositions64xyLow;\\nattribute vec2 instanceStartPositions64xyLow;\\nattribute vec2 instanceEndPositions64xyLow;\\nattribute vec2 instanceRightPositions64xyLow;\\nattribute float instanceStrokeWidths;\\nattribute vec4 instanceColors;\\nattribute vec3 instancePickingColors;\\nattribute vec2 instanceDashArrays;\\n\\nuniform float widthScale;\\nuniform float widthMinPixels;\\nuniform float widthMaxPixels;\\nuniform float jointType;\\nuniform float miterLimit;\\nuniform bool billboard;\\n\\nuniform float opacity;\\n\\nvarying vec4 vColor;\\nvarying vec2 vCornerOffset;\\nvarying float vMiterLength;\\nvarying vec2 vDashArray;\\nvarying vec2 vPathPosition;\\nvarying float vPathLength;\\n\\nconst float EPSILON = 0.001;\\nconst vec3 ZERO_OFFSET = vec3(0.0);\\n\\nfloat flipIfTrue(bool flag) {\\n  return -(float(flag) * 2. - 1.);\\n}\\nvec3 lineJoin(\\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\\n  float relativePosition, bool isEnd, bool isJoint,\\n  vec2 width, vec2 widthPixels\\n) {\\n  vec2 deltaA = (currPoint.xy - prevPoint.xy) / width;\\n  vec2 deltaB = (nextPoint.xy - currPoint.xy) / width;\\n\\n  float lenA = length(deltaA);\\n  float lenB = length(deltaB);\\n  lenA = lenA > EPSILON ? lenA : 0.0;\\n  lenB = lenB > EPSILON ? lenB : 0.0;\\n\\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\\n\\n  vec2 perpA = vec2(-dirA.y, dirA.x);\\n  vec2 perpB = vec2(-dirB.y, dirB.x);\\n  vec2 tangent = vec2(dirA + dirB);\\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\\n  vec2 perp = isEnd ? perpA : perpB;\\n  float L = isEnd ? lenA : lenB;\\n  float sinHalfA = abs(dot(miterVec, perp));\\n  float cosHalfA = abs(dot(dirA, miterVec));\\n\\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\\n\\n  float offsetScale = 1.0 / max(sinHalfA, EPSILON);\\n\\n  float cornerPosition = isJoint ?\\n    0.0 :\\n    flipIfTrue(turnsRight == (relativePosition > 0.0));\\n  cornerPosition *=\\n    float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) * cosHalfA);\\n  if (cornerPosition < 0.0) {\\n    offsetScale = min(offsetScale, L / max(cosHalfA, EPSILON));\\n  }\\n\\n  vMiterLength = cornerPosition >= 0.0 ?\\n    mix(offsetScale, 0.0, cornerPosition) :\\n    offsetScale * cornerPosition;\\n  vMiterLength -= sinHalfA * jointType;\\n\\n  float offsetDirection = mix(\\n    positions.y,\\n    mix(\\n      flipIfTrue(turnsRight),\\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\\n      cornerPosition\\n    ),\\n    step(0.0, cornerPosition)\\n  );\\n\\n  vec2 offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\\n  bool isCap = isStartCap || isEndCap;\\n  cornerPosition = isCap ? (1.0 - positions.z) : 0.;\\n  if (isStartCap) {\\n    offsetVec = mix(dirB, perpB, cornerPosition);\\n  }\\n  if (isEndCap) {\\n    offsetVec = mix(dirA, perpA, cornerPosition);\\n  }\\n  if (isCap) {\\n    offsetScale = mix(4.0 * jointType, 1.0, cornerPosition);\\n    vMiterLength = 1.0 - cornerPosition;\\n    offsetDirection = mix(flipIfTrue(isStartCap), positions.y, cornerPosition);\\n  }\\n\\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\\n  vDashArray = instanceDashArrays;\\n  vPathLength = L;\\n  vec2 offsetFromStartOfPath = vCornerOffset;\\n  if (isEnd) {\\n    offsetFromStartOfPath += deltaA;\\n  }\\n  vec2 dir = isEnd ? dirA : dirB;\\n  vPathPosition = vec2(\\n    positions.y + positions.z * offsetDirection,\\n    dot(offsetFromStartOfPath, dir)\\n  );\\n  geometry.uv = vPathPosition;\\n\\n  float isValid = step(instanceTypes, 3.5);\\n  vec3 offset = vec3(vCornerOffset * widthPixels * isValid, 0.0);\\n  DECKGL_FILTER_SIZE(offset, geometry);\\n  return currPoint + vec3(offset.xy / widthPixels * width, 0.0);\\n}\\nvec3 lineJoin(vec3 prevPoint, vec3 currPoint, vec3 nextPoint) {\\n\\n  float relativePosition = positions.y;\\n  bool isEnd = positions.x > EPSILON;\\n  bool isJoint = positions.z > EPSILON;\\n\\n  vec2 widthPixels = vec2(clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\\n    widthMinPixels, widthMaxPixels) / 2.0);\\n\\n  vec2 width = billboard ? project_pixel_size_to_clipspace(widthPixels) : project_pixel_size(widthPixels);\\n\\n  return lineJoin(\\n    prevPoint, currPoint, nextPoint,\\n    relativePosition, isEnd, isJoint,\\n    width, widthPixels\\n  );\\n}\\nvoid clipLine(inout vec4 position, vec4 refPosition) {\\n  if (position.w < EPSILON) {\\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\\n    position = refPosition + (position - refPosition) * r;\\n  }\\n}\\n\\nvoid main() {\\n  geometry.worldPosition = instanceStartPositions;\\n  geometry.worldPositionAlt = instanceEndPositions;\\n\\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\\n  picking_setPickingColor(instancePickingColors);\\n\\n  float isEnd = positions.x;\\n\\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\\n  vec2 prevPosition64xyLow = mix(instanceLeftPositions64xyLow, instanceStartPositions64xyLow, isEnd);\\n\\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\\n  vec2 currPosition64xyLow = mix(instanceStartPositions64xyLow, instanceEndPositions64xyLow, isEnd);\\n\\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\\n  vec2 nextPosition64xyLow = mix(instanceEndPositions64xyLow, instanceRightPositions64xyLow, isEnd);\\n\\n  if (billboard) {\\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64xyLow, ZERO_OFFSET);\\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64xyLow, ZERO_OFFSET, geometry.position);\\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64xyLow, ZERO_OFFSET);\\n\\n    clipLine(prevPositionScreen, currPositionScreen);\\n    clipLine(nextPositionScreen, currPositionScreen);\\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\\n\\n    vec3 pos = lineJoin(\\n      prevPositionScreen.xyz / prevPositionScreen.w,\\n      currPositionScreen.xyz / currPositionScreen.w,\\n      nextPositionScreen.xyz / nextPositionScreen.w\\n    );\\n\\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\\n  } else {\\n    prevPosition = project_position(prevPosition, prevPosition64xyLow);\\n    currPosition = project_position(currPosition, currPosition64xyLow);\\n    nextPosition = project_position(nextPosition, nextPosition64xyLow);\\n\\n    vec4 pos = vec4(\\n      lineJoin(prevPosition, currPosition, nextPosition),\\n      1.0);\\n    geometry.position = pos;\\n    gl_Position = project_common_position_to_clipspace(pos);\\n  }\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\n  DECKGL_FILTER_COLOR(vColor, geometry);\\n}\\n\";\n//# sourceMappingURL=path-layer-vertex.glsl.js.map","export default \"#define SHADER_NAME path-layer-fragment-shader\\n\\nprecision highp float;\\n\\nuniform float jointType;\\nuniform float miterLimit;\\nuniform float alignMode;\\n\\nvarying vec4 vColor;\\nvarying vec2 vCornerOffset;\\nvarying float vMiterLength;\\nvarying vec2 vDashArray;\\nvarying vec2 vPathPosition;\\nvarying float vPathLength;\\nfloat mod2(float a, float b) {\\n  return a - floor(a / b) * b;\\n}\\n\\nfloat round(float x) {\\n  return floor(x + 0.5);\\n}\\nbool dash_isFragInGap() {\\n  float solidLength = vDashArray.x;\\n  float gapLength = vDashArray.y;\\n\\n  float unitLength = solidLength + gapLength;\\n\\n  if (unitLength == 0.0) {\\n    return false;\\n  }\\n\\n  unitLength = mix(\\n    unitLength,\\n    vPathLength / round(vPathLength / unitLength),\\n    alignMode\\n  );\\n\\n  float offset = alignMode * solidLength / 2.0;\\n\\n  return gapLength > 0.0 &&\\n    vPathPosition.y >= 0.0 &&\\n    vPathPosition.y <= vPathLength &&\\n    mod2(vPathPosition.y + offset, unitLength) > solidLength;\\n}\\n\\nvoid main(void) {\\n  geometry.uv = vPathPosition;\\n  if (jointType > 0.0 && vMiterLength > 0.0 && length(vCornerOffset) > 1.0) {\\n    discard;\\n  }\\n  if (jointType == 0.0 && vMiterLength > miterLimit) {\\n    discard;\\n  }\\n  if (vColor.a == 0.0 || dash_isFragInGap()) {\\n    discard;\\n  }\\n  gl_FragColor = vColor;\\n\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\n}\\n\";\n//# sourceMappingURL=path-layer-fragment.glsl.js.map","import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _get from \"@babel/runtime/helpers/esm/get\";\nimport _inherits from \"@babel/runtime/helpers/esm/inherits\";\nimport { Layer } from '@deck.gl/core';\nimport { Model, Geometry } from '@luma.gl/core';\nimport PathTesselator from './path-tesselator';\nimport vs from './path-layer-vertex.glsl';\nimport fs from './path-layer-fragment.glsl';\nvar DEFAULT_COLOR = [0, 0, 0, 255];\nvar defaultProps = {\n  widthUnits: 'meters',\n  widthScale: {\n    type: 'number',\n    min: 0,\n    value: 1\n  },\n  widthMinPixels: {\n    type: 'number',\n    min: 0,\n    value: 0\n  },\n  widthMaxPixels: {\n    type: 'number',\n    min: 0,\n    value: Number.MAX_SAFE_INTEGER\n  },\n  rounded: false,\n  miterLimit: {\n    type: 'number',\n    min: 0,\n    value: 4\n  },\n  dashJustified: false,\n  billboard: false,\n  getPath: {\n    type: 'accessor',\n    value: function value(object) {\n      return object.path;\n    }\n  },\n  getColor: {\n    type: 'accessor',\n    value: DEFAULT_COLOR\n  },\n  getWidth: {\n    type: 'accessor',\n    value: 1\n  },\n  getDashArray: {\n    type: 'accessor',\n    value: [0, 0]\n  }\n};\nvar ATTRIBUTE_TRANSITION = {\n  enter: function enter(value, chunk) {\n    return chunk.length ? chunk.subarray(chunk.length - value.length) : value;\n  }\n};\n\nvar PathLayer = function (_Layer) {\n  _inherits(PathLayer, _Layer);\n\n  function PathLayer() {\n    _classCallCheck(this, PathLayer);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(PathLayer).apply(this, arguments));\n  }\n\n  _createClass(PathLayer, [{\n    key: \"getShaders\",\n    value: function getShaders() {\n      return _get(_getPrototypeOf(PathLayer.prototype), \"getShaders\", this).call(this, {\n        vs: vs,\n        fs: fs,\n        modules: ['project32', 'picking']\n      });\n    }\n  }, {\n    key: \"initializeState\",\n    value: function initializeState() {\n      var _this = this;\n\n      var noAlloc = true;\n      var attributeManager = this.getAttributeManager();\n      attributeManager.addInstanced({\n        startPositions: {\n          size: 3,\n          offset: 12,\n          type: 5130,\n          fp64: this.use64bitPositions(),\n          transition: ATTRIBUTE_TRANSITION,\n          accessor: 'getPath',\n          update: this.calculateStartPositions,\n          noAlloc: noAlloc,\n          shaderAttributes: {\n            instanceLeftPositions: {\n              offset: 0\n            },\n            instanceStartPositions: {\n              offset: 12\n            }\n          }\n        },\n        endPositions: {\n          size: 3,\n          type: 5130,\n          fp64: this.use64bitPositions(),\n          transition: ATTRIBUTE_TRANSITION,\n          accessor: 'getPath',\n          update: this.calculateEndPositions,\n          noAlloc: noAlloc,\n          shaderAttributes: {\n            instanceEndPositions: {\n              offset: 0\n            },\n            instanceRightPositions: {\n              offset: 12\n            }\n          }\n        },\n        instanceTypes: {\n          size: 1,\n          type: 5121,\n          update: this.calculateSegmentTypes,\n          noAlloc: noAlloc\n        },\n        instanceStrokeWidths: {\n          size: 1,\n          accessor: 'getWidth',\n          transition: ATTRIBUTE_TRANSITION,\n          defaultValue: 1\n        },\n        instanceDashArrays: {\n          size: 2,\n          accessor: 'getDashArray'\n        },\n        instanceColors: {\n          size: this.props.colorFormat.length,\n          type: 5121,\n          normalized: true,\n          accessor: 'getColor',\n          transition: ATTRIBUTE_TRANSITION,\n          defaultValue: DEFAULT_COLOR\n        },\n        instancePickingColors: {\n          size: 3,\n          type: 5121,\n          accessor: function accessor(object, _ref) {\n            var index = _ref.index,\n                value = _ref.target;\n            return _this.encodePickingColor(index, value);\n          }\n        }\n      });\n      this.setState({\n        pathTesselator: new PathTesselator({\n          fp64: this.use64bitPositions()\n        })\n      });\n    }\n  }, {\n    key: \"updateState\",\n    value: function updateState(_ref2) {\n      var oldProps = _ref2.oldProps,\n          props = _ref2.props,\n          changeFlags = _ref2.changeFlags;\n\n      _get(_getPrototypeOf(PathLayer.prototype), \"updateState\", this).call(this, {\n        props: props,\n        oldProps: oldProps,\n        changeFlags: changeFlags\n      });\n\n      var attributeManager = this.getAttributeManager();\n      var geometryChanged = changeFlags.dataChanged || changeFlags.updateTriggersChanged && (changeFlags.updateTriggersChanged.all || changeFlags.updateTriggersChanged.getPath);\n\n      if (geometryChanged) {\n        var pathTesselator = this.state.pathTesselator;\n        pathTesselator.updateGeometry({\n          data: props.data,\n          getGeometry: props.getPath,\n          positionFormat: props.positionFormat,\n          dataChanged: changeFlags.dataChanged\n        });\n        this.setState({\n          numInstances: pathTesselator.instanceCount,\n          bufferLayout: pathTesselator.bufferLayout\n        });\n\n        if (!changeFlags.dataChanged) {\n          attributeManager.invalidateAll();\n        }\n      }\n\n      if (changeFlags.extensionsChanged) {\n        var gl = this.context.gl;\n\n        if (this.state.model) {\n          this.state.model[\"delete\"]();\n        }\n\n        this.setState({\n          model: this._getModel(gl)\n        });\n        attributeManager.invalidateAll();\n      }\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(_ref3) {\n      var uniforms = _ref3.uniforms;\n      var viewport = this.context.viewport;\n      var _this$props = this.props,\n          rounded = _this$props.rounded,\n          billboard = _this$props.billboard,\n          miterLimit = _this$props.miterLimit,\n          widthUnits = _this$props.widthUnits,\n          widthScale = _this$props.widthScale,\n          widthMinPixels = _this$props.widthMinPixels,\n          widthMaxPixels = _this$props.widthMaxPixels,\n          dashJustified = _this$props.dashJustified;\n      var widthMultiplier = widthUnits === 'pixels' ? viewport.distanceScales.metersPerPixel[2] : 1;\n      this.state.model.setUniforms(Object.assign({}, uniforms, {\n        jointType: Number(rounded),\n        billboard: billboard,\n        alignMode: Number(dashJustified),\n        widthScale: widthScale * widthMultiplier,\n        miterLimit: miterLimit,\n        widthMinPixels: widthMinPixels,\n        widthMaxPixels: widthMaxPixels\n      })).draw();\n    }\n  }, {\n    key: \"_getModel\",\n    value: function _getModel(gl) {\n      var SEGMENT_INDICES = [0, 2, 1, 1, 2, 4, 1, 4, 3, 3, 4, 5];\n      var SEGMENT_POSITIONS = [0, 0, 1, 0, -1, 0, 0, 1, 0, 1, -1, 0, 1, 1, 0, 1, 0, 1];\n      return new Model(gl, Object.assign({}, this.getShaders(), {\n        id: this.props.id,\n        geometry: new Geometry({\n          drawMode: 4,\n          attributes: {\n            indices: new Uint16Array(SEGMENT_INDICES),\n            positions: new Float32Array(SEGMENT_POSITIONS)\n          }\n        }),\n        isInstanced: true\n      }));\n    }\n  }, {\n    key: \"calculateStartPositions\",\n    value: function calculateStartPositions(attribute) {\n      var pathTesselator = this.state.pathTesselator;\n      attribute.bufferLayout = pathTesselator.bufferLayout;\n      attribute.value = pathTesselator.get('startPositions');\n    }\n  }, {\n    key: \"calculateEndPositions\",\n    value: function calculateEndPositions(attribute) {\n      var pathTesselator = this.state.pathTesselator;\n      attribute.bufferLayout = pathTesselator.bufferLayout;\n      attribute.value = pathTesselator.get('endPositions');\n    }\n  }, {\n    key: \"calculateSegmentTypes\",\n    value: function calculateSegmentTypes(attribute) {\n      var pathTesselator = this.state.pathTesselator;\n      attribute.bufferLayout = pathTesselator.bufferLayout;\n      attribute.value = pathTesselator.get('segmentTypes');\n    }\n  }]);\n\n  return PathLayer;\n}(Layer);\n\nexport { PathLayer as default };\nPathLayer.layerName = 'PathLayer';\nPathLayer.defaultProps = defaultProps;\n//# sourceMappingURL=path-layer.js.map","import _classCallCheck from \"@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/esm/createClass\";\nimport { createIterable } from './iterable-utils';\nimport defaultTypedArrayManager from './typed-array-manager';\n\nvar Tesselator = function () {\n  function Tesselator() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Tesselator);\n\n    var _opts$attributes = opts.attributes,\n        attributes = _opts$attributes === void 0 ? {} : _opts$attributes;\n    this.typedArrayManager = defaultTypedArrayManager;\n    this.indexLayout = null;\n    this.bufferLayout = null;\n    this.vertexCount = 0;\n    this.instanceCount = 0;\n    this.attributes = {};\n    this._attributeDefs = attributes;\n    this.updateGeometry(opts);\n    Object.seal(this);\n  }\n\n  _createClass(Tesselator, [{\n    key: \"updateGeometry\",\n    value: function updateGeometry(_ref) {\n      var data = _ref.data,\n          getGeometry = _ref.getGeometry,\n          positionFormat = _ref.positionFormat,\n          dataChanged = _ref.dataChanged;\n      this.data = data;\n      this.getGeometry = getGeometry;\n      this.positionSize = positionFormat === 'XY' ? 2 : 3;\n\n      if (Array.isArray(dataChanged)) {\n        var _iteratorNormalCompletion = true;\n        var _didIteratorError = false;\n        var _iteratorError = undefined;\n\n        try {\n          for (var _iterator = dataChanged[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n            var dataRange = _step.value;\n\n            this._rebuildGeometry(dataRange);\n          }\n        } catch (err) {\n          _didIteratorError = true;\n          _iteratorError = err;\n        } finally {\n          try {\n            if (!_iteratorNormalCompletion && _iterator[\"return\"] != null) {\n              _iterator[\"return\"]();\n            }\n          } finally {\n            if (_didIteratorError) {\n              throw _iteratorError;\n            }\n          }\n        }\n      } else {\n        this._rebuildGeometry();\n      }\n    }\n  }, {\n    key: \"updatePartialGeometry\",\n    value: function updatePartialGeometry(_ref2) {\n      var startRow = _ref2.startRow,\n          endRow = _ref2.endRow;\n\n      this._rebuildGeometry({\n        startRow: startRow,\n        endRow: endRow\n      });\n    }\n  }, {\n    key: \"updateGeometryAttributes\",\n    value: function updateGeometryAttributes(geometry, startIndex, size) {\n      throw new Error('Not implemented');\n    }\n  }, {\n    key: \"getGeometrySize\",\n    value: function getGeometrySize(geometry) {\n      throw new Error('Not implemented');\n    }\n  }, {\n    key: \"_forEachGeometry\",\n    value: function _forEachGeometry(visitor, startRow, endRow) {\n      var data = this.data,\n          getGeometry = this.getGeometry;\n\n      var _createIterable = createIterable(data, startRow, endRow),\n          iterable = _createIterable.iterable,\n          objectInfo = _createIterable.objectInfo;\n\n      var _iteratorNormalCompletion2 = true;\n      var _didIteratorError2 = false;\n      var _iteratorError2 = undefined;\n\n      try {\n        for (var _iterator2 = iterable[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n          var object = _step2.value;\n          objectInfo.index++;\n          var geometry = getGeometry(object, objectInfo);\n          visitor(geometry, objectInfo.index);\n        }\n      } catch (err) {\n        _didIteratorError2 = true;\n        _iteratorError2 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion2 && _iterator2[\"return\"] != null) {\n            _iterator2[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError2) {\n            throw _iteratorError2;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"_rebuildGeometry\",\n    value: function _rebuildGeometry(dataRange) {\n      var _this = this;\n\n      if (!this.data || !this.getGeometry) {\n        return;\n      }\n\n      var indexLayout = this.indexLayout,\n          bufferLayout = this.bufferLayout;\n\n      if (!dataRange) {\n        indexLayout = [];\n        bufferLayout = [];\n      }\n\n      var _ref3 = dataRange || {},\n          _ref3$startRow = _ref3.startRow,\n          startRow = _ref3$startRow === void 0 ? 0 : _ref3$startRow,\n          _ref3$endRow = _ref3.endRow,\n          endRow = _ref3$endRow === void 0 ? Infinity : _ref3$endRow;\n\n      this._forEachGeometry(function (geometry, dataIndex) {\n        bufferLayout[dataIndex] = _this.getGeometrySize(geometry);\n      }, startRow, endRow);\n\n      var instanceCount = 0;\n      var _iteratorNormalCompletion3 = true;\n      var _didIteratorError3 = false;\n      var _iteratorError3 = undefined;\n\n      try {\n        for (var _iterator3 = bufferLayout[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n          var count = _step3.value;\n          instanceCount += count;\n        }\n      } catch (err) {\n        _didIteratorError3 = true;\n        _iteratorError3 = err;\n      } finally {\n        try {\n          if (!_iteratorNormalCompletion3 && _iterator3[\"return\"] != null) {\n            _iterator3[\"return\"]();\n          }\n        } finally {\n          if (_didIteratorError3) {\n            throw _iteratorError3;\n          }\n        }\n      }\n\n      var attributes = this.attributes,\n          _attributeDefs = this._attributeDefs,\n          typedArrayManager = this.typedArrayManager,\n          fp64 = this.fp64;\n\n      for (var name in _attributeDefs) {\n        var def = _attributeDefs[name];\n        def.copy = Boolean(dataRange);\n\n        if (!def.fp64Only || fp64) {\n          attributes[name] = typedArrayManager.allocate(attributes[name], instanceCount, def);\n        }\n      }\n\n      this.indexLayout = indexLayout;\n      this.bufferLayout = bufferLayout;\n      this.instanceCount = instanceCount;\n      var context = {\n        vertexStart: 0,\n        indexStart: 0\n      };\n\n      for (var i = 0; i < startRow; i++) {\n        context.vertexStart += bufferLayout[i];\n        context.indexStart += indexLayout[i] || 0;\n      }\n\n      this._forEachGeometry(function (geometry, dataIndex) {\n        var geometrySize = bufferLayout[dataIndex];\n        context.geometryIndex = dataIndex;\n        context.geometrySize = geometrySize;\n\n        _this.updateGeometryAttributes(geometry, context);\n\n        context.vertexStart += geometrySize;\n        context.indexStart += indexLayout[dataIndex] || 0;\n      }, startRow, endRow);\n\n      var vertexCount = context.indexStart;\n\n      for (var _i = endRow; _i < indexLayout.length; _i++) {\n        vertexCount += indexLayout[_i];\n      }\n\n      this.vertexCount = vertexCount;\n    }\n  }]);\n\n  return Tesselator;\n}();\n\nexport { Tesselator as default };\n//# sourceMappingURL=tesselator.js.map","import './lib/init';\nimport './shaderlib';\nexport { COORDINATE_SYSTEM } from './lib/constants';\nexport { default as LightingEffect } from './effects/lighting/lighting-effect';\nexport { default as PointLight } from './effects/lighting/point-light';\nexport { default as DirectionalLight } from './effects/lighting/directional-light';\nexport { default as _CameraLight } from './effects/lighting/camera-light';\nexport { default as _SunLight } from './effects/lighting/sun-light';\nexport { default as PostProcessEffect } from './effects/post-process-effect';\nexport { default as _LayersPass } from './passes/layers-pass';\nexport { default as Deck } from './lib/deck';\nexport { default as LayerManager } from './lib/layer-manager';\nexport { default as AttributeManager } from './lib/attribute-manager';\nexport { default as Layer } from './lib/layer';\nexport { default as CompositeLayer } from './lib/composite-layer';\nexport { default as DeckRenderer } from './lib/deck-renderer';\nexport { default as Viewport } from './viewports/viewport';\nexport { default as WebMercatorViewport } from './viewports/web-mercator-viewport';\nexport { default as project } from './shaderlib/project/project';\nexport { default as project64 } from './shaderlib/project64/project64';\nexport { default as View } from './views/view';\nexport { default as MapView } from './views/map-view';\nexport { default as FirstPersonView } from './views/first-person-view';\nexport { default as ThirdPersonView } from './views/third-person-view';\nexport { default as OrbitView } from './views/orbit-view';\nexport { default as PerspectiveView } from './views/perspective-view';\nexport { default as OrthographicView } from './views/orthographic-view';\nexport { default as Controller } from './controllers/controller';\nexport { default as MapController } from './controllers/map-controller';\nexport { default as _FirstPersonController } from './controllers/first-person-controller';\nexport { default as _OrbitController } from './controllers/orbit-controller';\nexport { default as _OrthographicController } from './controllers/orthographic-controller';\nexport { default as Effect } from './lib/effect';\nexport { TRANSITION_EVENTS } from './controllers/transition-manager';\nexport { default as LinearInterpolator } from './transitions/linear-interpolator';\nexport { default as FlyToInterpolator } from './transitions/viewport-fly-to-interpolator';\nexport { default as log } from './utils/log';\nimport { flattenVertices, fillArray } from './utils/flatten';\nexport { createIterable } from './utils/iterable-utils';\nexport { fp64LowPart } from './utils/math-utils';\nimport Tesselator from './utils/tesselator';\nimport { count } from './utils/count';\nimport memoize from './utils/memoize';\nexport { AmbientLight } from '@luma.gl/core';\nexport { LayerExtension } from './lib/layer-extension';\nexport var experimental = {\n  Tesselator: Tesselator,\n  flattenVertices: flattenVertices,\n  fillArray: fillArray,\n  count: count,\n  memoize: memoize\n};\n//# sourceMappingURL=index.js.map"],"sourceRoot":""}