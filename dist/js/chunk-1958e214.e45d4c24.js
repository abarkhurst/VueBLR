(window["webpackJsonp"]=window["webpackJsonp"]||[]).push([["chunk-1958e214"],{"72db":function(t,e,n){"use strict";var i=n("d4ec"),o=n("bee2"),r=n("99de"),s=n("7e84"),a=n("45eb"),c=n("262e"),l=n("2bb8"),f=n("4b61"),u=n("0bba"),d=n("a88e"),h=d["a"].Tesselator,v=1,p=2,y=4,P=function(t){function e(t){var n=t.data,o=t.getGeometry,a=t.positionFormat,c=t.fp64;return Object(i["a"])(this,e),Object(r["a"])(this,Object(s["a"])(e).call(this,{data:n,getGeometry:o,positionFormat:a,attributes:{startPositions:{size:3,padding:3,type:c?Float64Array:Float32Array},endPositions:{size:3,padding:3,type:c?Float64Array:Float32Array},segmentTypes:{size:1,type:Uint8ClampedArray},startPositions64XyLow:{size:2,padding:2,fp64Only:!0},endPositions64XyLow:{size:2,padding:2,fp64Only:!0}}}))}return Object(c["a"])(e,t),Object(o["a"])(e,[{key:"get",value:function(t){return this.attributes[t]}},{key:"getGeometrySize",value:function(t){var e=this.getPathLength(t);return e<2?0:this.isClosed(t)?e<3?0:e+1:e-1}},{key:"updateGeometryAttributes",value:function(t,e){var n=this.attributes,i=n.startPositions,o=n.endPositions,r=n.segmentTypes,s=e.geometrySize;if(0!==s)for(var a,c,l=this.isClosed(t),f=e.vertexStart,u=0;u<s;f++,u++)a=c||this.getPointOnPath(t,0),c=this.getPointOnPath(t,u+1),r[f]=0,0===u&&(r[f]+=l?y:v),u===s-1&&(r[f]+=l?y:p),i[3*f+3]=a[0],i[3*f+4]=a[1],i[3*f+5]=a[2]||0,o[3*f]=c[0],o[3*f+1]=c[1],o[3*f+2]=c[2]||0}},{key:"getPathLength",value:function(t){return Number.isFinite(t[0])?t.length/this.positionSize:t.length}},{key:"getPointOnPath",value:function(t,e){if(Number.isFinite(t[0])){var n=this.positionSize;return e*n>=t.length&&(e+=1-t.length/n),[t[e*n],t[e*n+1],3===n?t[e*n+2]:0]}return e>=t.length&&(e+=1-t.length),t[e]}},{key:"isClosed",value:function(t){var e=this.getPathLength(t),n=this.getPointOnPath(t,0),i=this.getPointOnPath(t,e-1);return n[0]===i[0]&&n[1]===i[1]&&n[2]===i[2]}}]),e}(h),g="#define SHADER_NAME path-layer-vertex-shader\n\nattribute vec3 positions;\n\nattribute float instanceTypes;\nattribute vec3 instanceStartPositions;\nattribute vec3 instanceEndPositions;\nattribute vec3 instanceLeftPositions;\nattribute vec3 instanceRightPositions;\nattribute vec2 instanceLeftPositions64xyLow;\nattribute vec2 instanceStartPositions64xyLow;\nattribute vec2 instanceEndPositions64xyLow;\nattribute vec2 instanceRightPositions64xyLow;\nattribute float instanceStrokeWidths;\nattribute vec4 instanceColors;\nattribute vec3 instancePickingColors;\nattribute vec2 instanceDashArrays;\n\nuniform float widthScale;\nuniform float widthMinPixels;\nuniform float widthMaxPixels;\nuniform float jointType;\nuniform float miterLimit;\nuniform bool billboard;\n\nuniform float opacity;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vDashArray;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\n\nconst float EPSILON = 0.001;\nconst vec3 ZERO_OFFSET = vec3(0.0);\n\nfloat flipIfTrue(bool flag) {\n  return -(float(flag) * 2. - 1.);\n}\nvec3 lineJoin(\n  vec3 prevPoint, vec3 currPoint, vec3 nextPoint,\n  float relativePosition, bool isEnd, bool isJoint,\n  vec2 width, vec2 widthPixels\n) {\n  vec2 deltaA = (currPoint.xy - prevPoint.xy) / width;\n  vec2 deltaB = (nextPoint.xy - currPoint.xy) / width;\n\n  float lenA = length(deltaA);\n  float lenB = length(deltaB);\n  lenA = lenA > EPSILON ? lenA : 0.0;\n  lenB = lenB > EPSILON ? lenB : 0.0;\n\n  vec2 dirA = lenA > 0. ? normalize(deltaA) : vec2(0.0, 0.0);\n  vec2 dirB = lenB > 0. ? normalize(deltaB) : vec2(0.0, 0.0);\n\n  vec2 perpA = vec2(-dirA.y, dirA.x);\n  vec2 perpB = vec2(-dirB.y, dirB.x);\n  vec2 tangent = vec2(dirA + dirB);\n  tangent = length(tangent) > 0. ? normalize(tangent) : perpA;\n  vec2 miterVec = vec2(-tangent.y, tangent.x);\n  vec2 perp = isEnd ? perpA : perpB;\n  float L = isEnd ? lenA : lenB;\n  float sinHalfA = abs(dot(miterVec, perp));\n  float cosHalfA = abs(dot(dirA, miterVec));\n\n  bool turnsRight = dirA.x * dirB.y > dirA.y * dirB.x;\n\n  float offsetScale = 1.0 / max(sinHalfA, EPSILON);\n\n  float cornerPosition = isJoint ?\n    0.0 :\n    flipIfTrue(turnsRight == (relativePosition > 0.0));\n  cornerPosition *=\n    float(cornerPosition <= 0.0 || sinHalfA < min(lenA, lenB) * cosHalfA);\n  if (cornerPosition < 0.0) {\n    offsetScale = min(offsetScale, L / max(cosHalfA, EPSILON));\n  }\n\n  vMiterLength = cornerPosition >= 0.0 ?\n    mix(offsetScale, 0.0, cornerPosition) :\n    offsetScale * cornerPosition;\n  vMiterLength -= sinHalfA * jointType;\n\n  float offsetDirection = mix(\n    positions.y,\n    mix(\n      flipIfTrue(turnsRight),\n      positions.y * flipIfTrue(turnsRight == (positions.x == 1.)),\n      cornerPosition\n    ),\n    step(0.0, cornerPosition)\n  );\n\n  vec2 offsetVec = mix(miterVec, -tangent, step(0.5, cornerPosition));\n  offsetScale = mix(offsetScale, 1.0 / max(cosHalfA, 0.001), step(0.5, cornerPosition));\n  bool isStartCap = lenA == 0.0 || (!isEnd && (instanceTypes == 1.0 || instanceTypes == 3.0));\n  bool isEndCap = lenB == 0.0 || (isEnd && (instanceTypes == 2.0 || instanceTypes == 3.0));\n  bool isCap = isStartCap || isEndCap;\n  cornerPosition = isCap ? (1.0 - positions.z) : 0.;\n  if (isStartCap) {\n    offsetVec = mix(dirB, perpB, cornerPosition);\n  }\n  if (isEndCap) {\n    offsetVec = mix(dirA, perpA, cornerPosition);\n  }\n  if (isCap) {\n    offsetScale = mix(4.0 * jointType, 1.0, cornerPosition);\n    vMiterLength = 1.0 - cornerPosition;\n    offsetDirection = mix(flipIfTrue(isStartCap), positions.y, cornerPosition);\n  }\n\n  vCornerOffset = offsetVec * offsetDirection * offsetScale;\n  vDashArray = instanceDashArrays;\n  vPathLength = L;\n  vec2 offsetFromStartOfPath = vCornerOffset;\n  if (isEnd) {\n    offsetFromStartOfPath += deltaA;\n  }\n  vec2 dir = isEnd ? dirA : dirB;\n  vPathPosition = vec2(\n    positions.y + positions.z * offsetDirection,\n    dot(offsetFromStartOfPath, dir)\n  );\n  geometry.uv = vPathPosition;\n\n  float isValid = step(instanceTypes, 3.5);\n  vec3 offset = vec3(vCornerOffset * widthPixels * isValid, 0.0);\n  DECKGL_FILTER_SIZE(offset, geometry);\n  return currPoint + vec3(offset.xy / widthPixels * width, 0.0);\n}\nvec3 lineJoin(vec3 prevPoint, vec3 currPoint, vec3 nextPoint) {\n\n  float relativePosition = positions.y;\n  bool isEnd = positions.x > EPSILON;\n  bool isJoint = positions.z > EPSILON;\n\n  vec2 widthPixels = vec2(clamp(project_size_to_pixel(instanceStrokeWidths * widthScale),\n    widthMinPixels, widthMaxPixels) / 2.0);\n\n  vec2 width = billboard ? project_pixel_size_to_clipspace(widthPixels) : project_pixel_size(widthPixels);\n\n  return lineJoin(\n    prevPoint, currPoint, nextPoint,\n    relativePosition, isEnd, isJoint,\n    width, widthPixels\n  );\n}\nvoid clipLine(inout vec4 position, vec4 refPosition) {\n  if (position.w < EPSILON) {\n    float r = (EPSILON - refPosition.w) / (position.w - refPosition.w);\n    position = refPosition + (position - refPosition) * r;\n  }\n}\n\nvoid main() {\n  geometry.worldPosition = instanceStartPositions;\n  geometry.worldPositionAlt = instanceEndPositions;\n\n  vColor = vec4(instanceColors.rgb, instanceColors.a * opacity);\n  picking_setPickingColor(instancePickingColors);\n\n  float isEnd = positions.x;\n\n  vec3 prevPosition = mix(instanceLeftPositions, instanceStartPositions, isEnd);\n  vec2 prevPosition64xyLow = mix(instanceLeftPositions64xyLow, instanceStartPositions64xyLow, isEnd);\n\n  vec3 currPosition = mix(instanceStartPositions, instanceEndPositions, isEnd);\n  vec2 currPosition64xyLow = mix(instanceStartPositions64xyLow, instanceEndPositions64xyLow, isEnd);\n\n  vec3 nextPosition = mix(instanceEndPositions, instanceRightPositions, isEnd);\n  vec2 nextPosition64xyLow = mix(instanceEndPositions64xyLow, instanceRightPositions64xyLow, isEnd);\n\n  if (billboard) {\n    vec4 prevPositionScreen = project_position_to_clipspace(prevPosition, prevPosition64xyLow, ZERO_OFFSET);\n    vec4 currPositionScreen = project_position_to_clipspace(currPosition, currPosition64xyLow, ZERO_OFFSET, geometry.position);\n    vec4 nextPositionScreen = project_position_to_clipspace(nextPosition, nextPosition64xyLow, ZERO_OFFSET);\n\n    clipLine(prevPositionScreen, currPositionScreen);\n    clipLine(nextPositionScreen, currPositionScreen);\n    clipLine(currPositionScreen, mix(nextPositionScreen, prevPositionScreen, isEnd));\n\n    vec3 pos = lineJoin(\n      prevPositionScreen.xyz / prevPositionScreen.w,\n      currPositionScreen.xyz / currPositionScreen.w,\n      nextPositionScreen.xyz / nextPositionScreen.w\n    );\n\n    gl_Position = vec4(pos * currPositionScreen.w, currPositionScreen.w);\n  } else {\n    prevPosition = project_position(prevPosition, prevPosition64xyLow);\n    currPosition = project_position(currPosition, currPosition64xyLow);\n    nextPosition = project_position(nextPosition, nextPosition64xyLow);\n\n    vec4 pos = vec4(\n      lineJoin(prevPosition, currPosition, nextPosition),\n      1.0);\n    geometry.position = pos;\n    gl_Position = project_common_position_to_clipspace(pos);\n  }\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\n  DECKGL_FILTER_COLOR(vColor, geometry);\n}\n",m="#define SHADER_NAME path-layer-fragment-shader\n\nprecision highp float;\n\nuniform float jointType;\nuniform float miterLimit;\nuniform float alignMode;\n\nvarying vec4 vColor;\nvarying vec2 vCornerOffset;\nvarying float vMiterLength;\nvarying vec2 vDashArray;\nvarying vec2 vPathPosition;\nvarying float vPathLength;\nfloat mod2(float a, float b) {\n  return a - floor(a / b) * b;\n}\n\nfloat round(float x) {\n  return floor(x + 0.5);\n}\nbool dash_isFragInGap() {\n  float solidLength = vDashArray.x;\n  float gapLength = vDashArray.y;\n\n  float unitLength = solidLength + gapLength;\n\n  if (unitLength == 0.0) {\n    return false;\n  }\n\n  unitLength = mix(\n    unitLength,\n    vPathLength / round(vPathLength / unitLength),\n    alignMode\n  );\n\n  float offset = alignMode * solidLength / 2.0;\n\n  return gapLength > 0.0 &&\n    vPathPosition.y >= 0.0 &&\n    vPathPosition.y <= vPathLength &&\n    mod2(vPathPosition.y + offset, unitLength) > solidLength;\n}\n\nvoid main(void) {\n  geometry.uv = vPathPosition;\n  if (jointType > 0.0 && vMiterLength > 0.0 && length(vCornerOffset) > 1.0) {\n    discard;\n  }\n  if (jointType == 0.0 && vMiterLength > miterLimit) {\n    discard;\n  }\n  if (vColor.a == 0.0 || dash_isFragInGap()) {\n    discard;\n  }\n  gl_FragColor = vColor;\n\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\n}\n";n.d(e,"a",(function(){return S}));var x=[0,0,0,255],b={widthUnits:"meters",widthScale:{type:"number",min:0,value:1},widthMinPixels:{type:"number",min:0,value:0},widthMaxPixels:{type:"number",min:0,value:Number.MAX_SAFE_INTEGER},rounded:!1,miterLimit:{type:"number",min:0,value:4},dashJustified:!1,billboard:!1,getPath:{type:"accessor",value:function(t){return t.path}},getColor:{type:"accessor",value:x},getWidth:{type:"accessor",value:1},getDashArray:{type:"accessor",value:[0,0]}},L={enter:function(t,e){return e.length?e.subarray(e.length-t.length):t}},S=function(t){function e(){return Object(i["a"])(this,e),Object(r["a"])(this,Object(s["a"])(e).apply(this,arguments))}return Object(c["a"])(e,t),Object(o["a"])(e,[{key:"getShaders",value:function(){return Object(a["a"])(Object(s["a"])(e.prototype),"getShaders",this).call(this,{vs:g,fs:m,modules:["project32","picking"]})}},{key:"initializeState",value:function(){var t=this,e=!0,n=this.getAttributeManager();n.addInstanced({startPositions:{size:3,offset:12,type:5130,fp64:this.use64bitPositions(),transition:L,accessor:"getPath",update:this.calculateStartPositions,noAlloc:e,shaderAttributes:{instanceLeftPositions:{offset:0},instanceStartPositions:{offset:12}}},endPositions:{size:3,type:5130,fp64:this.use64bitPositions(),transition:L,accessor:"getPath",update:this.calculateEndPositions,noAlloc:e,shaderAttributes:{instanceEndPositions:{offset:0},instanceRightPositions:{offset:12}}},instanceTypes:{size:1,type:5121,update:this.calculateSegmentTypes,noAlloc:e},instanceStrokeWidths:{size:1,accessor:"getWidth",transition:L,defaultValue:1},instanceDashArrays:{size:2,accessor:"getDashArray"},instanceColors:{size:this.props.colorFormat.length,type:5121,normalized:!0,accessor:"getColor",transition:L,defaultValue:x},instancePickingColors:{size:3,type:5121,accessor:function(e,n){var i=n.index,o=n.target;return t.encodePickingColor(i,o)}}}),this.setState({pathTesselator:new P({fp64:this.use64bitPositions()})})}},{key:"updateState",value:function(t){var n=t.oldProps,i=t.props,o=t.changeFlags;Object(a["a"])(Object(s["a"])(e.prototype),"updateState",this).call(this,{props:i,oldProps:n,changeFlags:o});var r=this.getAttributeManager(),c=o.dataChanged||o.updateTriggersChanged&&(o.updateTriggersChanged.all||o.updateTriggersChanged.getPath);if(c){var l=this.state.pathTesselator;l.updateGeometry({data:i.data,getGeometry:i.getPath,positionFormat:i.positionFormat,dataChanged:o.dataChanged}),this.setState({numInstances:l.instanceCount,bufferLayout:l.bufferLayout}),o.dataChanged||r.invalidateAll()}if(o.extensionsChanged){var f=this.context.gl;this.state.model&&this.state.model["delete"](),this.setState({model:this._getModel(f)}),r.invalidateAll()}}},{key:"draw",value:function(t){var e=t.uniforms,n=this.context.viewport,i=this.props,o=i.rounded,r=i.billboard,s=i.miterLimit,a=i.widthUnits,c=i.widthScale,l=i.widthMinPixels,f=i.widthMaxPixels,u=i.dashJustified,d="pixels"===a?n.distanceScales.metersPerPixel[2]:1;this.state.model.setUniforms(Object.assign({},e,{jointType:Number(o),billboard:r,alignMode:Number(u),widthScale:c*d,miterLimit:s,widthMinPixels:l,widthMaxPixels:f})).draw()}},{key:"_getModel",value:function(t){var e=[0,2,1,1,2,4,1,4,3,3,4,5],n=[0,0,1,0,-1,0,0,1,0,1,-1,0,1,1,0,1,0,1];return new f["a"](t,Object.assign({},this.getShaders(),{id:this.props.id,geometry:new u["a"]({drawMode:4,attributes:{indices:new Uint16Array(e),positions:new Float32Array(n)}}),isInstanced:!0}))}},{key:"calculateStartPositions",value:function(t){var e=this.state.pathTesselator;t.bufferLayout=e.bufferLayout,t.value=e.get("startPositions")}},{key:"calculateEndPositions",value:function(t){var e=this.state.pathTesselator;t.bufferLayout=e.bufferLayout,t.value=e.get("endPositions")}},{key:"calculateSegmentTypes",value:function(t){var e=this.state.pathTesselator;t.bufferLayout=e.bufferLayout,t.value=e.get("segmentTypes")}}]),e}(l["a"]);S.layerName="PathLayer",S.defaultProps=b},a88e:function(t,e,n){"use strict";var i=n("664e"),o=n("d4ec"),r=n("bee2"),s=n("ae9c"),a=n("6f48"),c=function(){function t(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};Object(o["a"])(this,t);var n=e.attributes,i=void 0===n?{}:n;this.typedArrayManager=a["a"],this.indexLayout=null,this.bufferLayout=null,this.vertexCount=0,this.instanceCount=0,this.attributes={},this._attributeDefs=i,this.updateGeometry(e),Object.seal(this)}return Object(r["a"])(t,[{key:"updateGeometry",value:function(t){var e=t.data,n=t.getGeometry,i=t.positionFormat,o=t.dataChanged;if(this.data=e,this.getGeometry=n,this.positionSize="XY"===i?2:3,Array.isArray(o)){var r=!0,s=!1,a=void 0;try{for(var c,l=o[Symbol.iterator]();!(r=(c=l.next()).done);r=!0){var f=c.value;this._rebuildGeometry(f)}}catch(u){s=!0,a=u}finally{try{r||null==l["return"]||l["return"]()}finally{if(s)throw a}}}else this._rebuildGeometry()}},{key:"updatePartialGeometry",value:function(t){var e=t.startRow,n=t.endRow;this._rebuildGeometry({startRow:e,endRow:n})}},{key:"updateGeometryAttributes",value:function(t,e,n){throw new Error("Not implemented")}},{key:"getGeometrySize",value:function(t){throw new Error("Not implemented")}},{key:"_forEachGeometry",value:function(t,e,n){var i=this.data,o=this.getGeometry,r=Object(s["a"])(i,e,n),a=r.iterable,c=r.objectInfo,l=!0,f=!1,u=void 0;try{for(var d,h=a[Symbol.iterator]();!(l=(d=h.next()).done);l=!0){var v=d.value;c.index++;var p=o(v,c);t(p,c.index)}}catch(y){f=!0,u=y}finally{try{l||null==h["return"]||h["return"]()}finally{if(f)throw u}}}},{key:"_rebuildGeometry",value:function(t){var e=this;if(this.data&&this.getGeometry){var n=this.indexLayout,i=this.bufferLayout;t||(n=[],i=[]);var o=t||{},r=o.startRow,s=void 0===r?0:r,a=o.endRow,c=void 0===a?1/0:a;this._forEachGeometry((function(t,n){i[n]=e.getGeometrySize(t)}),s,c);var l=0,f=!0,u=!1,d=void 0;try{for(var h,v=i[Symbol.iterator]();!(f=(h=v.next()).done);f=!0){var p=h.value;l+=p}}catch(E){u=!0,d=E}finally{try{f||null==v["return"]||v["return"]()}finally{if(u)throw d}}var y=this.attributes,P=this._attributeDefs,g=this.typedArrayManager,m=this.fp64;for(var x in P){var b=P[x];b.copy=Boolean(t),b.fp64Only&&!m||(y[x]=g.allocate(y[x],l,b))}this.indexLayout=n,this.bufferLayout=i,this.instanceCount=l;for(var L={vertexStart:0,indexStart:0},S=0;S<s;S++)L.vertexStart+=i[S],L.indexStart+=n[S]||0;this._forEachGeometry((function(t,o){var r=i[o];L.geometryIndex=o,L.geometrySize=r,e.updateGeometryAttributes(t,L),L.vertexStart+=r,L.indexStart+=n[o]||0}),s,c);for(var w=L.indexStart,A=c;A<n.length;A++)w+=n[A];this.vertexCount=w}}}]),t}(),l=n("1982"),f=n("3885");n.d(e,"a",(function(){return u}));var u={Tesselator:c,flattenVertices:i["c"],fillArray:i["a"],count:l["a"],memoize:f["a"]}}}]);
//# sourceMappingURL=chunk-1958e214.e45d4c24.js.map